<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Repertórios — JS Ouija</title>

<style>
  :root{
    --bg:#070403;        /* fundo preto profundo */
    --panel:#2b160f;     /* marrom escuro */
    --accent:#6b0b0b;    /* bordo */
    --muted:#c9bfb8;
    --glass: rgba(255,255,255,0.03);
    --radius:12px;
    --maxw:520px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;min-height:100vh;background:linear-gradient(180deg,var(--bg),#120908);color:var(--muted);
    font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;display:flex;justify-content:center;padding:18px;
  }
  .wrap{width:100%;max-width:var(--maxw)}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{margin:0;color:var(--accent);font-size:1.2rem}
  .card{background:linear-gradient(180deg,var(--glass),transparent);padding:12px;border-radius:var(--radius);box-shadow:0 8px 20px rgba(0,0,0,0.6);margin-bottom:12px}
  .muted{color:#9d8f8a;font-size:.95rem}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .btn{
    background:var(--accent);color:#fff;padding:10px 12px;border-radius:10px;text-decoration:none;border:none;font-weight:700;
  }
  .btn.outline{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);font-weight:700}
  .btn.small{padding:8px 10px;font-size:.95rem}
  .q-card{padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent)}
  .question{font-weight:700;color:#e9dcd6;margin-bottom:10px}
  .choices{display:flex;flex-direction:column;gap:8px}
  .choice-btn{background:transparent;border:1px solid rgba(255,255,255,0.05);padding:12px;border-radius:10px;color:var(--muted);text-align:left;font-weight:700}
  .choice-btn:hover{border-color:var(--accent);cursor:pointer}
  .choice-btn[disabled]{opacity:.6;cursor:not-allowed}
  .toast{margin-top:12px;padding:12px;border-radius:10px;display:none}
  .toast.ok{background:rgba(80,150,90,0.12);color:#bfe6b7;border:1px solid rgba(80,150,90,0.18)}
  .toast.err{background:linear-gradient(90deg, rgba(180,60,60,0.06), rgba(140,40,40,0.03));color:#ffb7b7;border:1px dashed rgba(200,60,60,0.25);font-family:monospace}
  .encoded{font-family:monospace;background:rgba(0,0,0,0.16);padding:8px;border-radius:8px;margin-top:10px;color:#e6dcd6;overflow-x:auto}
  .progress{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .chip{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:.85rem}
  /* modal final */
  .modal{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:50;backdrop-filter:blur(2px);
  }
  .modal .box{background:linear-gradient(180deg,var(--panel),#1b0f0d);padding:18px;border-radius:14px;color:var(--muted);max-width:420px;text-align:center}
  .glitch{display:inline-block;position:relative}
  .glitch::after,.glitch::before{content:attr(data-text);position:absolute;left:0;top:0;mix-blend-mode:screen;opacity:.6}
  .glitch::before{color:#ff5f5f;transform:translate(-2px,-1px)}
  .glitch::after{color:#7fb1ff;transform:translate(2px,1px)}
  @media(min-width:640px){ .row.center{justify-content:flex-start} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Repertórios — JavaScript</h1>
      <a href="index.html" class="muted">← Voltar</a>
    </header>

    <section class="card">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
        <div>
          <div class="muted">Escolha um repertório</div>
          <div class="row" style="margin-top:8px">
            <button class="btn" data-repo="0">A — Caesar</button>
            <button class="btn" data-repo="1">B — Base64</button>
            <button class="btn outline" data-repo="2">C — Hex</button>
          </div>
        </div>

        <div style="text-align:right">
          <div class="muted">Acertos</div>
          <div id="score" class="chip">0</div>
          <div style="height:6px"></div>
          <div class="muted">Erros</div>
          <div id="errors" class="chip">0</div>
        </div>
      </div>
    </section>

    <section id="repoArea" class="card" style="display:none">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong id="rTitle">—</strong>
          <div id="rDesc" class="muted" style="font-size:.95rem;margin-top:4px">—</div>
        </div>
        <div style="text-align:right">
          <div class="muted" style="font-size:.85rem">Codificação parcial</div>
          <div id="encoded" class="encoded">—</div>
        </div>
      </div>

      <div class="q-card" style="margin-top:12px">
        <div class="question" id="qText"></div>
        <div class="choices" id="choices"></div>
        <div id="toast" class="toast"></div>
        <div class="progress" id="progress"></div>
        <div style="margin-top:10px;text-align:right">
          <button id="nextBtn" class="btn small" style="display:none">Próxima</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Modal final (quando todas codificações reveladas) -->
  <div id="finalModal" class="modal" style="display:none">
    <div class="box">
      <h2 class="glitch" data-text="Parabéns!">Parabéns!</h2>
      <p style="margin-top:8px">Você revelou todas as codificações.</p>
      <p style="margin-top:6px;font-family:monospace;color:#e6dcd6" id="allDecodedPreview"></p>
      <div style="margin-top:12px">
        <button id="goRanking" class="btn">Ir para Ranking</button>
        <button id="closeModal" class="btn outline" style="margin-left:8px">Fechar</button>
      </div>
    </div>
  </div>

<script>
/* ========= CONFIGURAÇÃO ======== */
const PHRASE = "tinky winky os aguarda novamente";

/* ====== codificações definidas ====== */
function caesarEncode(s, shift = 3){
  const A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  return s.split('').map(ch=>{
    const idx = A.indexOf(ch);
    if(idx === -1) return ch;
    const base = idx < 26 ? 0 : 26;
    return A[(idx-base+shift)%26 + base];
  }).join('');
}
function toBase64(s){
  try { return btoa(unescape(encodeURIComponent(s))); } catch(e){ return btoa(s); }
}
function toHex(s){
  const arr = [];
  for(let i=0;i<s.length;i++){
    arr.push(s.charCodeAt(i).toString(16).padStart(2,'0'));
  }
  return arr.join(' ');
}

/* encoded strings */
const encodedStrings = [
  caesarEncode(PHRASE,3),    // Caesar
  toBase64(PHRASE),          // Base64
  toHex(PHRASE)              // Hex
];

/* decide chunk sizes for reveal (reasonable UX) */
const chunkConfig = [
  { // caesar: reveal per word
    split: encodedStrings[0].split(' '), // words
    joiner: ' '
  },
  { // base64: reveal per 6 chars
    split: (function(s){ const n=6, out=[]; for(let i=0;i<s.length;i+=n) out.push(s.slice(i,i+n)); return out; })(encodedStrings[1]),
    joiner: ''
  },
  { // hex: reveal per byte (space-separated)
    split: encodedStrings[2].split(' '),
    joiner: ' '
  }
];

/* ===== Questões (36) - parei/peguei do seu gabarito */
const questoes = [
  /* nível médio 1-12 */
  {n:1, q:'Qual será o resultado da expressão: (10 >= 8) && (5 < 3)?', opts:['true','false','undefined','erro de sintaxe'], correct:1},
  {n:2, q:'Saída do código: let nota=7; if(nota>=6){console.log(\"Aprovado\");} console.log(\"Fim\");', opts:['Aprovado','Fim','Aprovado / Fim','Nenhuma saída'], correct:2},
  {n:3, q:'Quantas vezes o console.log será executado? for(let i=0; i <= 5; i++){ console.log(i); }', opts:['4 vezes','5 vezes','6 vezes','7 vezes'], correct:2},
  {n:4, q:'Qual operador lógico retorna TRUE quando PELO MENOS UMA condição é verdadeira?', opts:['&& (AND)','|| (OR)','! (NOT)','== (IGUAL)'], correct:1},
  {n:5, q:'Analise: let idade=17; ... Qual será a saída?', opts:['Maior','Quase','Menor','Maior / Quase'], correct:1},
  {n:6, q:'Qual será o valor final de x? while(x<5){ x++; }', opts:['4','5','6','0'], correct:1},
  {n:7, q:'Valor de resultado: let a=10; let b=5; let resultado = a - b * 2;', opts:['10','0','20','5'], correct:1},
  {n:8, q:'Qual expressão retorna TRUE? (x=15,y=20)', opts:['(x>20)&&(y>15)','(x<10)||(y<15)','(x>=15)&&(y>=20)','(x==20)||(y==15)'], correct:2},
  {n:9, q:'Saída for i=2; i<=8; i+=2', opts:['2,4,6,8','2,4,6','0,2,4,6,8','2,4,6,8,10'], correct:0},
  {n:10,q:'Se temperatura=20, saída do if(temperatura>25){Calor}else{Frio}', opts:['Calor','Frio','Calor / Frio','Nenhuma saída'], correct:1},
  {n:11,q:'Quantas vezes "Olá" será impresso? while(cont<=4){...}', opts:['3','4','5','Infinitas'], correct:1},
  {n:12,q:'Qual será valor de y? let x=10; let y = x/2 + 3*2;', opts:['11','16','13','26'], correct:0},

  /* difícil 13-24 */
  {n:13,q:'for i<3; for j<2 -> quantas execuções?', opts:['3','5','6','9'], correct:2},
  {n:14,q:'Saída com nota=7 faltas=6 (condicionais)', opts:['Aprovado','Reprovado por falta','Reprovado por nota','Nenhuma saída'], correct:1},
  {n:15,q:'Último valor impresso de i: i+=3 enquanto i<10', opts:['6','9','10','12'], correct:1},
  {n:16,q:'Qual expressão retorna FALSE? (a=5,b=10,c=15)', opts:['(a<b)&&(b<c)','(a>b)||(c>b)','!(a==5)&&(b==10)','(a<c)||(b>c)'], correct:2},
  {n:17,q:'Saída for decremento i=10;i>5;i-=2', opts:['10,8,6','10,8,6,4','10,9,...,6','10,8'], correct:0},
  {n:18,q:'Condicional encadeada com x=15 -> saída?', opts:['A','B','C','D'], correct:1},
  {n:19,q:'Valor final soma de 1 a 5', opts:['10','15','20','5'], correct:1},
  {n:20,q:'while x=1; while(x<20){ x = x*2; } quantas iterações?', opts:['3','4','5','6'], correct:2},
  {n:21,q:'Valor resultado = 10 + 5*2 - 8/4', opts:['28','18','22','17'], correct:1},
  {n:22,q:'Quantos pares serão impressos de 1 a 10?', opts:['4','5','6','10'], correct:1},
  {n:23,q:'if(!ativo) com ativo=false -> saída?', opts:['Ativo','Inativo','true','false'], correct:1},
  {n:24,q:'Valor final cont decremento i de 5 a 1', opts:['0','4','5','6'], correct:2},

  /* avançado 25-36 */
  {n:25,q:'valor do algoritmo com i<=4 j<=3 soma i*j', opts:['50','60','70','80'], correct:1},
  {n:26,q:'Quantas vezes "X" será impresso (condição i+j>6)?', opts:['6','8','10','12'], correct:2},
  {n:27,q:'Equivalente a !(a>5 && b<10)', opts:['(a<=5)&&(b>=10)','(a<=5)||(b>=10)','(a<5)&&(b>10)','(a>5)||(b<10)'], correct:1},
  {n:28,q:'Saída do bloco com a=10,b=20,c=15', opts:['A','B','C','Nenhuma saída'], correct:1},
  {n:29,q:'Resultado final for i=0,j=10 i<5', opts:['45','50','55','60'], correct:1},
  {n:30,q:'while x<=100 multiplicando por 3 -> quantas iterações?', opts:['3','4','5','6'], correct:2},
  {n:31,q:'FizzBuzz com num=15 -> saída?', opts:['Fizz','Buzz','FizzBuzz','15'], correct:2},
  {n:32,q:'pares/ímpares em 1..10', opts:['pares=4,impares=6','pares=5,impares=5','pares=6,impares=4','pares=5,impares=6'], correct:1},
  {n:33,q:'Salario 3000 -> qual saída?', opts:['3000','3150','3300','3450'], correct:2},
  {n:34,q:'6º número gerado (Fibonacci) mostrado no código', opts:['5','8','13','21'], correct:0},
  {n:35,q:'Valor final total (while aninhado)', opts:['12','15','18','21'], correct:2},
  {n:36,q:'resultado multiplicando ímpares de 1 a 5', opts:['15','105','120','1'], correct:0}
];

/* ===== estado do jogo ===== */
let activeRepo = null;     // 0..2
let revealedCounts = [0,0,0]; // number of chunks revealed per repo
let score = 0, errors = 0;
let currentQuestion = null;
let questionAnswered = false;

/* ===== helpers UI ===== */
const repoArea = document.getElementById('repoArea');
const rTitle = document.getElementById('rTitle');
const rDesc  = document.getElementById('rDesc');
const encodedEl = document.getElementById('encoded');
const qText = document.getElementById('qText');
const choicesEl = document.getElementById('choices');
const toast = document.getElementById('toast');
const nextBtn = document.getElementById('nextBtn');
const scoreEl = document.getElementById('score');
const errorsEl = document.getElementById('errors');
const progressEl = document.getElementById('progress');
const finalModal = document.getElementById('finalModal');
const allDecodedPreview = document.getElementById('allDecodedPreview');

/* inicializa botões de repertório */
document.querySelectorAll('[data-repo]').forEach(b=>{
  b.addEventListener('click', ()=> openRepo(Number(b.dataset.repo)));
});

/* abrir repertório */
function openRepo(id){
  activeRepo = id;
  revealedCounts[id] = revealedCounts[id] || 0;
  const titles = ['Repertório A — Caesar (shift 3)','Repertório B — Base64','Repertório C — Hexadecimal'];
  const descs  = ['Cada acerto revela uma parte (palavras) da codificação Caesar.',
                  'Cada acerto revela um trecho (6 chars) da codificação Base64.',
                  'Cada acerto revela bytes (hex) da codificação hexadecimal.'];
  rTitle.textContent = titles[id];
  rDesc.textContent = descs[id];
  repoArea.style.display = 'block';
  updateEncodedDisplay();
  renderProgress();
  nextQuestion(); // já mostra a primeira
}

/* escolhe questão aleatória (com repetição permitida) */
function pickRandomQuestion(){
  const idx = Math.floor(Math.random()*questoes.length);
  return JSON.parse(JSON.stringify(questoes[idx])); // cópia simples
}

/* renderiza uma questão */
function renderQuestion(q){
  currentQuestion = q;
  questionAnswered = false;
  qText.textContent = `(${q.n}) ${q.q}`;
  choicesEl.innerHTML = '';
  q.opts.forEach((opt,i)=>{
    const btn = document.createElement('button');
    btn.className = 'choice-btn';
    btn.textContent = String.fromCharCode(65+i) + '. ' + opt;
    btn.onclick = ()=> onSelect(i, btn);
    choicesEl.appendChild(btn);
  });
  toast.style.display = 'none';
  nextBtn.style.display = 'none';
}

/* seleção de alternativa */
function onSelect(i, btn){
  if(questionAnswered) return;
  questionAnswered = true;
  // bloquear todas
  Array.from(choicesEl.children).forEach(x=>x.disabled=true);
  const correct = currentQuestion.correct;
  if(i === correct){
    // acerto
    score++;
    scoreEl.textContent = score;
    btn.style.borderColor = 'rgba(80,180,100,0.95)';
    showToastReveal(true);
    revealNextChunk(activeRepo);
  } else {
    errors++;
    errorsEl.textContent = errors;
    btn.style.borderColor = 'rgba(200,80,80,0.95)';
    showToastReveal(false);
    // pequeno glitch visual na mensagem
  }
  nextBtn.style.display = 'inline-block';
}

/* próxima questão */
nextBtn.addEventListener('click', ()=>{
  nextQuestion();
});

/* pega e mostra nova questão (aleatória) */
function nextQuestion(){
  const q = pickRandomQuestion();
  renderQuestion(q);
}

/* mostrar toast com popup: se ok mostra trecho revelado, se errado mostra glitch */
function showToastReveal(ok){
  toast.style.display = 'block';
  if(ok){
    toast.className = 'toast ok';
    const snippet = getCurrentRevealedSnippet(activeRepo);
    toast.textContent = 'Correto — trecho revelado: ' + snippet;
  } else {
    toast.className = 'toast err';
    toast.textContent = glitchText('ERRO: segmento corrompido — 0x0F');
    // e animar texto rapidamente
    glitchAnimate(toast);
  }
}

/* revela o próximo chunk do repo ativo */
function revealNextChunk(repoIndex){
  if(repoIndex === null) return;
  const cfg = chunkConfig[repoIndex];
  const totalChunks = cfg.split.length;
  revealedCounts[repoIndex] = Math.min(totalChunks, revealedCounts[repoIndex] + 1);
  updateEncodedDisplay();
  renderProgress();
  checkAllRevealed();
}

/* retorna string parcial já revelada (com ... se faltar) */
function getCurrentRevealedSnippet(repoIndex){
  const cfg = chunkConfig[repoIndex];
  const revealed = revealedCounts[repoIndex] || 0;
  if(revealed === 0) return '—';
  const part = cfg.split.slice(0, revealed).join(cfg.joiner);
  return part + (revealed < cfg.split.length ? ' …' : '');
}

/* atualiza a área encoded */
function updateEncodedDisplay(){
  if(activeRepo === null) { encodedEl.textContent = '—'; return; }
  encodedEl.textContent = getCurrentRevealedSnippet(activeRepo);
}

/* renderiza progresso visual (chips por repo) */
function renderProgress(){
  progressEl.innerHTML = '';
  for(let i=0;i<3;i++){
    const c = document.createElement('div');
    c.className='chip';
    const total = chunkConfig[i].split.length;
    c.textContent = `R${i+1}: ${revealedCounts[i]}/${total}`;
    progressEl.appendChild(c);
  }
}

/* se todos os chunks de todos repos foram revelados -> final */
function checkAllRevealed(){
  let all = true;
  for(let i=0;i<3;i++){
    if((revealedCounts[i]||0) < chunkConfig[i].split.length) { all = false; break; }
  }
  if(all) showFinalModal();
}

/* exibe modal final */
function showFinalModal(){
  allDecodedPreview.textContent = [
    'Caesar: ' + encodedStrings[0],
    'Base64: ' + encodedStrings[1],
    'Hex: ' + encodedStrings[2]
  ].join('\n');
  finalModal.style.display = 'flex';
}

/* fechar modal */
document.getElementById('closeModal').addEventListener('click', ()=> finalModal.style.display='none');
document.getElementById('goRanking').addEventListener('click', ()=>{
  // opcional: salvar pontuação local e redirecionar para ranking.html
  const list = JSON.parse(localStorage.getItem('jsg_ranking')||'[]');
  list.push({ groupName: 'LocalPlayer', time: (new Date()).toISOString(), score });
  localStorage.setItem('jsg_ranking', JSON.stringify(list));
  window.location.href = 'ranking.html';
});

/* pequena função para texto glitch */
function glitchText(s){
  return s.split('').map(ch=> Math.random()<0.18 ? String.fromCharCode(33+Math.floor(Math.random()*30)) : ch).join('');
}
/* animação de glitch no elemento (texto muda por curtos instantes) */
function glitchAnimate(el){
  const orig = el.textContent;
  let steps = 0;
  const iv = setInterval(()=>{
    el.textContent = glitchText(orig);
    steps++;
    if(steps>5){ clearInterval(iv); el.textContent = orig; }
  },110);
}

/* ===== get current partial snippet (used in toast) */
function getCurrentRevealedSnippet(repoIndex){
  return getCurrentRevealedSnippetCached(repoIndex);
}
/* avoid name clash: implement actual function above; fix after building */
function getCurrentRevealedSnippetCached(repoIndex){
  const cfg = chunkConfig[repoIndex];
  const revealed = revealedCounts[repoIndex] || 0;
  if(revealed === 0) return '—';
  const part = cfg.split.slice(0, revealed).join(cfg.joiner);
  return part + (revealed < cfg.split.length ? ' …' : '');
}

/* fix small duplicated function issue: ensure updateEncodedDisplay uses correct getter */
function overwriteGetCurrent(){
  window._getRevealed = function(repoIndex){
    const cfg = chunkConfig[repoIndex];
    const revealed = revealedCounts[repoIndex] || 0;
    if(revealed === 0) return '—';
    const part = cfg.split.slice(0, revealed).join(cfg.joiner);
    return part + (revealed < cfg.split.length ? ' …' : '');
  };
}
overwriteGetCurrent();
/* override one place used earlier */
function getCurrentRevealedSnippet(repoIndex){ return window._getRevealed(repoIndex); }

/* inicial render */
renderProgress();
scoreEl.textContent = score;
errorsEl.textContent = errors;
</script>
</body>
</html>
